# This file automatically generated by tools\build\gen-cat.pl

# From src\core\NativeTypes.pm

use nqp-mo;

# We'll re-export all of the HOWs that we import from the meta-objects
# library. (Questionable whether we should need to do this - maybe the
# set of mappings the setting has should just be taken as the default
# for any program using it. OTOH, there's not a good way to factor
# this just yet.)
my module EXPORTHOW {
    ($?PACKAGE.WHO)<module>       := NQPModuleHOW;
    ($?PACKAGE.WHO)<class>        := NQPClassHOW;
    ($?PACKAGE.WHO)<class-attr>   := NQPAttribute;
    ($?PACKAGE.WHO)<grammar>      := NQPClassHOW;
    ($?PACKAGE.WHO)<grammar-attr> := NQPAttribute;
    ($?PACKAGE.WHO)<role>         := NQPParametricRoleHOW;
    ($?PACKAGE.WHO)<role-attr>    := NQPAttribute;
    ($?PACKAGE.WHO)<native>       := NQPNativeHOW;
}

my native int is repr('P6int') { }

my native num is repr('P6num') { }

my native str is repr('P6str') { }

# From src\core\NQPRoutine.pm

my knowhow NQPRoutine {
    has $!do;
    has $!signature;
    has $!dispatchees;
    has $!dispatch_cache;
    method add_dispatchee($code) {
        $!dispatch_cache := nqp::null();
        nqp::push($!dispatchees, $code);
    }
    method is_dispatcher() {
        nqp::defined($!dispatchees)
    }
#    method derive_dispatcher() {
#        # Clone the underlying VM code ref.
#        my $do  := nqp::clone($!do);
#        
#        # Clone and attach the code object.
#        my $der := nqp::clone(self);
#        nqp::bindattr($der, NQPRoutine, '$!do', $do);
#        nqp::bindattr($der, NQPRoutine, '$!dispatchees', nqp::clone($!dispatchees));
#        nqp::setcodeobj($do, $der);
#        
#        # If needed, arrange for a fixup of the cloned code-ref.
#        my $clone_callback := pir::getprop__PPs($!do, 'CLONE_CALLBACK');
#        if nqp::defined($clone_callback) {
#            $clone_callback($!do, $do, $der);
#        }
#        
#        $der
#    }
#    method clone() {
#        # Clone the underlying VM code ref.
#        my $do  := nqp::clone($!do);
#        
#        # Clone and attach the code object.
#        my $der := nqp::clone(self);
#        nqp::bindattr($der, NQPRoutine, '$!do', $do);
#        nqp::setcodeobj($do, $der);
#        
#        # If needed, arrange for a fixup of the cloned code-ref.
#        my $clone_callback := pir::getprop__PPs($!do, 'CLONE_CALLBACK');
#        if nqp::defined($clone_callback) {
#            $clone_callback($!do, $do, $der);
#        }
#        
#        $der
#    }
    method !set_name($name) {
        nqp::setcodename($!do, $name);
    }
    method name() {
        nqp::getcodename($!do)
    }
}
nqp::setinvokespec(NQPRoutine, NQPRoutine, '$!do', nqp::null);
nqp::setboolspec(NQPRoutine, 5, nqp::null());
#pir::stable_publish_vtable_handler_mapping__vPP(NQPRoutine,
#    nqp::hash('get_string', nqp::list(NQPRoutine, '$!do')));

my knowhow NQPSignature {
    has $!types;
    has $!definednesses;
}

# From src\core\NQPMu.pm

my class NQPMu {
    method CREATE() {
        nqp::create(self)
    }

    method bless(NQPMu:U $self: *%attributes) {
        my $instance := self.CREATE();
        $instance.BUILDALL(|%attributes);
        $instance
    }
    
    method BUILDALL(NQPMu:D $self: *%attrinit) {
        # Get the build plan.
        my $build_plan := self.HOW.BUILDALLPLAN(self);
        my $count      := nqp::elems($build_plan);
        my $i          := 0;
        while $i < $count {
            my $task := nqp::atpos($build_plan, $i);
            my $code := nqp::atpos($task, 0);
            $i := $i + 1;
            if nqp::iseq_i($code, 0) {
                # Custom BUILD call.
                nqp::atpos($task, 1)(self, |%attrinit);
            }
            elsif nqp::iseq_i($code, 1) {
                # See if we have a value to initialize this attr with.
                my $key_name := nqp::atpos($task, 2);
                if nqp::existskey(%attrinit, $key_name) {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 3), %attrinit{$key_name});
                }
            }
            elsif nqp::iseq_i($code, 2) {
                # See if we have a value to initialize this attr with;
                # if not, set it to an empty array.
                my $key_name := nqp::atpos($task, 2);
                if nqp::existskey(%attrinit, $key_name) {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 3), %attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 3), nqp::list());
                }
            }
            elsif nqp::iseq_i($code, 3) {
                # See if we have a value to initialize this attr with;
                # if not, set it to an empty array.
                my $key_name := nqp::atpos($task, 2);
                if nqp::existskey(%attrinit, $key_name) {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 3), %attrinit{$key_name});
                }
                else {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 3), nqp::hash());
                }
            }
            elsif nqp::iseq_i($code, 4) {
                unless nqp::attrinited(self, nqp::atpos($task, 1), nqp::atpos($task, 2)) {
                    nqp::bindattr(self, nqp::atpos($task, 1), nqp::atpos($task, 2),
                        nqp::atpos($task, 3)(self,
                            nqp::getattr(self, nqp::atpos($task, 1), nqp::atpos($task, 2))));
                }
            }
            else {
                nqp::die("Invalid BUILDALLPLAN");
            }
        }
        self
    }

    method new(*%attributes) {
        self.bless(|%attributes);
    }
}

sub print(*@args) {
    for @args {
        nqp::print($_);
    }
    1;
}

sub say(*@args) {
    print(|@args, "\n");
}

sub join($delim, @things) {
    my @strs;
    for @things { nqp::push(@strs, ~$_) }
    nqp::join($delim, @strs)
}

# From src\core\testing.pm

my $test_counter       := 0;
my $todo_upto_test_num := 0;
my $todo_reason        := '';

sub plan($quantity) {
    say("1..$quantity");
}

sub ok($condition, $desc?) {
    $test_counter := $test_counter + 1;

    unless $condition {
        print("not ");
    }
    print("ok $test_counter");
    if $desc {
        print(" - $desc");
    }
    if $test_counter <= $todo_upto_test_num {
        print($todo_reason);
    }
    print("\n");
    
    $condition ?? 1 !! 0
}

sub todo($reason, $count) {
    $todo_upto_test_num := $test_counter + $count;
    $todo_reason        := "# TODO $reason";
}

sub skip($desc) {
    $test_counter := $test_counter + 1;
    say("ok $test_counter # SKIP $desc\n");
}

# From src\core\YOUAREHERE.pm

1;
{YOU_ARE_HERE}

# vim: set ft=perl6 nomodifiable :
